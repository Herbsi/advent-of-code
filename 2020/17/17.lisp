(ql:quickload :iterate)
(use-package :iter)

(ql:quickload :str)

(defclass life ()
  ((cells :initarg :cells :reader cells)
   (size :initarg :life-size)
   (front :initform 0)
   (initial-state :initarg :initial-state)))

(defun make-life (initial-state &optional (size 24))
  (let ((cells (make-array `(,size ,size ,size 2) :initial-element 0)))
    (destructuring-bind (n m) (array-dimensions initial-state)
      (iter (for i from 0 to (1- n))
        (iter (for j from 0 to (1- m))
          (setf (aref cells
                      (+ (floor (/ (- size n) 2)) i)
                      (+ (floor (/ (- size m) 2)) j)
                      (floor (/ size 2))
                      0)
                (aref initial-state i j)))))
    (make-instance 'life :cells cells :initial-state initial-state :life-size size)))

(defun life-step (life)
  (with-slots (cells front size) life
    (labels ((count-neighbors (x y z)
               (iter outer (for i in '(-1 0 1))
                 (iter (for j in '(-1 0 1))
                   (iter (for k in '(-1 0 1))
                     (in outer (sum (if (or (= i j k 0)
                                            (not (and (<= 0 (+ i x) (1- size))
                                                      (<= 0 (+ j y) (1- size))
                                                      (<= 0 (+ k z) (1- size)))))
                                        0
                                        (aref cells (+ x i)
                                              (+ y j)
                                              (+ z k)
                                              front)))))))) 
             (alive? (x y z) (= 1 (aref cells x y z front)))
             (next-state (x y z)
               (let ((no-neighbors (count-neighbors x y z)))
                 (cond ((and (alive? x y z)
                             (<= 2 no-neighbors 3)) 1)
                       ((and (not (alive? x y z))
                             (= 3 no-neighbors)) 1)
                       (t 0)))))
      (iter (for x from 0 to (1- size))
        (iter (for y from 0 to (1- size))
          (iter (for z from 0 to (1- size))
            (setf (aref cells x y z (mod (1+ front) 2))
                  (next-state x y z)))))
      (setf front (mod (1+ front) 2)))))

(defun life-count-alive (life)
  (with-slots (cells front size) life
    (iter outer (for i from 0 to (1- size))
      (iter (for j from 0 to (1- size))
        (iter (for k from 0 to (1- size))
          (in outer (sum (aref cells i j k front))))))))

(defun life-reset (life)
  (with-slots (cells front initial-state)
      (destructuring-bind (n m) (array-dimensions initial-state)
        (iter (for i from 0 to (1- n))
          (iter (for j from 0 to (1- m))
            (setf (aref cells
                        (+ (floor (/ (- size n) 2)) i)
                        (+ (floor (/ (- size m) 2)) j)
                        (floor (/ size 2))
                        front)
                  (aref initial-state i j)))))))


(defun make-life-part-2 (initial-state &optional (size 24))
  (let ((cells (make-array `(,size ,size ,size ,size 2)
                           :initial-element 0
                           :adjustable t))
        (front 0))
    ;; initialize cells by placing input 
    ;; at the middle of height 0
    (labels ((reset-cells ()
               (destructuring-bind (n m) (array-dimensions initial-state)
                 (iter (for i from 0 to (1- n))
                   (iter (for j from 0 to (1- m))
                     (setf (aref cells
                                 (+ (floor (/ (- size n) 2)) i)
                                 (+ (floor (/ (- size m) 2)) j)
                                 (floor (/ size 2))
                                 (floor (/ size 2))
                                 front)
                           (aref initial-state i j))))))
             (count-neighbors (x y z w)
               (iter outer (for i in '(-1 0 1))
                 (iter (for j in '(-1 0 1))
                   (iter (for k in '(-1 0 1))
                     (iter (for l in '(-1 0 1))
                       (in outer (sum (if (or (= i j k l 0)
                                              (not (and (<= 0 (+ i x) (1- size))
                                                        (<= 0 (+ j y) (1- size))
                                                        (<= 0 (+ k z) (1- size))
                                                        (<= 0 (+ w l) (1- size)))))
                                          0
                                          (aref cells
                                                (+ x i)
                                                (+ y j)
                                                (+ z k)
                                                (+ w l)
                                                front)))))))))
             (alive? (x y z w)
               (= 1 (aref cells x y z w front)))
             (next-state (x y z w)
               (let ((no-neighbors (count-neighbors x y z w)))
                 (cond ((and (alive? x y z w)
                             (<= 2 no-neighbors 3)) 1)
                       ((and (not (alive? x y z w))
                             (= 3 no-neighbors)) 1)
                       (t 0)))))
      (reset-cells)
      (lambda (action)
        (case action
          (cells cells) 
          (count-alive
           (iter outer (for i from 0 to (1- size))
             (iter (for j from 0 to (1- size))
               (iter (for k from 0 to (1- size))
                 (iter (for l from 0 to (1- size))
                   (in outer (sum (aref cells i j k l front))))))))
          (step
           (iter (for x from 0 to (1- size))
             (iter (for y from 0 to (1- size))
               (iter (for z from 0 to (1- size))
                 (iter (for w from 0 to (1- size))
                   (setf (aref cells x y z w (mod (1+ front) 2))
                         (next-state x y z w))))))
           (setf front (mod (1+ front) 2)))
          (reset (reset-cells)))))))

(defun read-initial-state (string)
  (let* ((lines (str:lines string))
         (n (length lines))
         (m (length (str:split "" (car lines) :omit-nulls t))))
    (make-array `(,n ,m)
                :initial-contents
                (mapcar (lambda (line)
                          (mapcar #'read-from-string
                                  (str:split ""
                                             (str:replace-all "#" "1" (str:replace-all "." "0" line))
                                             :omit-nulls t)))
                        lines))))

(iter
  (with life-3d = (make-life (read-initial-state (uiop:read-file-string "input.txt"))))
  (with life-4d = (make-life-part-2 (read-initial-state (uiop:read-file-string "input.txt"))))
  (repeat 6)
  (life-step life-3d)
  (funcall life-4d 'step)
  (finally (format t "~a~%~a~%"
                   (life-count-alive life-3d)
                   (funcall life-4d 'count-alive))))
